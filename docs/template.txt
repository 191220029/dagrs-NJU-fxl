发明名称：一种用于分布式系统的变异测试框架的实现方法
申请类型：1发明    0实用新型
申请人：南京大学
申请人地址：江苏省南京市栖霞区仙林大道163号
邮编：210023
统一社会信用代码：12100000466007458M
发明人名单：冯洋、林哲远、赵东辰
发明人名单中第一发明人身份证号码：510522198807080251
联系人：
提前公布：1请求早日公布该专利申请，1进入实质审查
代理师：李玉平 15252466729，lyping_08@163.com
代理机构：南京乐羽知行专利代理事务所（普通合伙）
 
本发明公开一种用于分布式系统的变异测试框架的实现方法，测试人员在选定待测系统后，从变异算子库中选择变异测试所需的变异算子；然后，变异测试框架会基于被选择的变异算子，在待测系统的源码基础上生成变异体，并通过静态分析和动态执行相结合的方法筛选掉一些无效变异体或等效变异体；之后进入变异体执行阶段，变异测试框架会根据待测系统单元测试的覆盖率信息，按照一定的优先级依次载入某个变异体，在变异后的待测系统上运行待测系统的测试套件并收集结果。最后，当所有变异体都被载入和运行完成之后，变异测试框架会收集整理数据，形成可读的测试报告，从而在一定程度上反映待测系统的测试套件的质量。 

指定图1为摘要附图


 
1. 一种用于分布式系统的变异测试框架的实现方法，其特征在于，测试人员在选定待测系统后，从变异算子库中选择变异测试所需的变异算子；然后，变异测试框架会基于被选择的变异算子，在待测系统的源码基础上生成变异体，并通过静态分析和动态执行相结合的方法筛选掉一些无效变异体或等效变异体；之后进入变异体执行阶段，变异测试框架会根据待测系统单元测试的覆盖率信息，按照设定的优先级依次载入某个变异体，在变异后的待测系统上运行待测系统的测试套件并收集结果；最后，当所有变异体都被载入和运行完成之后，变异测试框架会收集整理数据，形成可读的测试报告。
2. 根据权利要求1所述的用于分布式系统的变异测试框架的实现方法，其特征在于，根据分布式系统集群内通过网络交互、高并发和一致性保障三个特点，基于分布式系统中的故障模式和漏洞的文献综述和错误报告分析，设计并实现了网络、并发和一致性三类的变异算子；
每个变异算子基于JavaParser实现，识别待测系统源码中的模式并对其按照算子的约束进行修改；采用模块化的设计理念和静态工厂、模板方法的设计模式，使得用户能根据需要，实现自己客制化的变异算子。
3. 根据权利要求1所述的用于分布式系统的变异测试框架的实现方法，其特征在于，用户在使用本变异测试框架对目标系统进行变异测试时需要定义：（1）变异算子列表，用于生成变异体；（2）待测系统路径；（3）待测系统构造工具，用于支持系统编译和测试套件执行；（4）待测系统源码通配符，用于识别需要扫描的源码文件列表，在这些源码文件中才会生成变异体；（5）待测系统构建输出路径，用于在字节码层面识别和删除等效变异体；（6）结果输出路径：用于输出测试结果；（7）是否使用docker，对于不支持并行测试的测试套件，使用docker并行执行以充分利用计算资源，（8）是否开启覆盖率分析，如果开启覆盖率分析，在后续测试套件运行环节，框架仅会根据用户传入的单元测试覆盖率文件，执行覆盖变异位置的测试用例，而不会全量执行所有的测试用例。
4. 根据权利要求1所述的用于分布式系统的变异测试框架的实现方法，其特征在于，变异体生成中，在用户定义了待测系统源码扫描路径之后，变异测试框架按照文件通配符扫描所有用户指定的源码文件，并依据用户指定的变异算子列表在这些待测系统源码文件的基础上生成变异体；本变异测试框架每次只对一处代码进行变异，即只生成一阶变异体。
5. 根据权利要求1或4所述的用于分布式系统的变异测试框架的实现方法，其特征在于，在变异体生成过程中，本框架会通过静态分析方法过滤掉一些无效或等效的变异体。
6. 根据权利要求1或4所述的用于分布式系统的变异测试框架的实现方法，其特征在于，通过实际编译的方式剔除语法或语义错误的变异体以及消除等效变异体；具体而言，当所有变异体全部生成完成之后，变异测试框架会载入每个变异体，并对载入变异体之后的待测系统进行编译；如果编译失败，则说明变异体存在语法或语义错误，是无效变异体；如果编译成功，框架会收集变异体的变异结果并对所有变异体的编译结果进行两两对比；如果某两个变异体的编译结果完全等价，则说明这两个变异体经过编译优化之后，仍然是等效变异体，对一组等效变异体，变异测试框架只会保留该组中随机一个变异体。
7. 根据权利要求1所述的用于分布式系统的变异测试框架的实现方法，其特征在于，变异体执行中，对生成的所有变异体依次执行待测系统的测试套件，记录测试结果；具体而言，对于每个变异体，测试执行引擎会根据设定的频率和相关性运行测试套件。
8. 根据权利要求7所述的用于分布式系统的变异测试框架的实现方法，其特征在于，如果开启了覆盖率分析功能，对于每个变异体，变异测试框架仅会执行覆盖变异位置的测试用例，而不会全量执行所有的测试用例；运行时间超过预期设定值的测试将被终止；如果待测系统的测试套件不支持并发测试，变异测试框架提供了docker模式，通过在多个docker容器内同时运行多个变异。
9. 根据权利要求1所述的用于分布式系统的变异测试框架的实现方法，其特征在于，对于每个变异体执行完测试套件之后的输出结果，变异测试框架根据设定关键字的分析结果，根据测试用例的成功或失败来判断该变异体是否存活，并收集运行时间、覆盖测试样例的统计信息；汇总所有变异体的测试结果，对测试结果进行评估，计算变异覆盖率、变异杀死率指标，生成可读的测试报告。
 
一种用于分布式系统的变异测试框架的实现方法
技术领域
本发明属于软件测试技术领域，尤其适用于软件测试中的分布式系统变异测试领域，具体涉及一种用于分布式系统的变异测试框架的实现方法，特别是设计和实现了一套通用的具有分布式特性的变异算子，用于评估分布式系统单元测试集的健壮性、覆盖范围和可靠性。本发明适用于各种分布式系统的质量保障，涵盖存储系统、流处理平台、协调服务等多种分布式架构场景。
背景技术
在当今数字化时代，分布式系统已成为现代社会和软件开发的关键组成部分，其广泛应用于大规模电商平台、云计算服务及基础设施建设等领域。分布式系统通过将数据与计算任务分布到网络中的多个位置，显著提高了处理效率、系统稳定性和可扩展性。然而，随着技术的持续进步和应用需求的增长，分布式系统的质量保障逐渐成为软件工程中的热点问题。
在分布式系统的长期开发过程中，代码因不断变化而引发了对测试用例的调整需求，这种变化在开源项目中尤为明显。这些变化可能带来潜在的测试不安全性，尤其是在分布式系统中，其复杂性及组件间的相互依赖性显著提高了隐藏缺陷出现的可能性。传统测试方法（如单元测试）虽被广泛用于分布式系统的安全性和稳定性维护，但其覆盖范围和有效性往往难以满足复杂系统的需求。例如，即使是基本的“领导者选举”（Leader Election）机制，也可能出现无法终止的情况，而原有测试方法却无法发现这些问题。
变异测试作为一种高效的软件测试技术，通过在程序的特定部分引入小变化来检测测试集的缺陷，提供了比传统测试更为强大的测试方法。然而，目前市面上的变异测试工具主要针对单机系统设计，未能充分考虑分布式系统中的独特挑战。例如：
（1）现有变异算子缺乏对网络异常、线程并发及文件一致性问题的有效模拟。
（2）针对分布式架构设计的变异算子尚未系统化，大多数变异算子仍针对特定运算或操作符的简单修改，这些变异算子并不具有分布式特征。
（3）考虑到分布式系统的代码规模，在分布式系统中应用传统变异算子会产生大量的变异体，进意味着大量的时间成本和计算成本。
这导致在针对分布式系统进行编译测试的场景下，使用现有的变异测试工具和现有的变异算子会导致变异测试效率低下，在浪费计算资源的同时难以发现代码中的隐藏缺陷。
发明内容
发明目的：针对现有技术中存在的问题与不足，本发明提供一种用于分布式系统的变异测试框架（简称DisMuTe）的实现方法，通过设计针对分布式系统特性的通用变异操作符，全面提升分布式系统变异测试的效率和有效性。
技术方案：一种用于分布式系统的变异测试框架（简称DisMuTe）的实现方法，测试人员在选定待测系统后，从变异算子库中选择变异测试所需的变异算子；然后，变异测试框架会基于被选择的变异算子，在待测系统的源码基础上生成变异体，并通过静态分析和动态执行相结合的方法筛选掉一些无效变异体或等效变异体；之后进入变异体执行阶段，变异测试框架会根据待测系统单元测试的覆盖率信息，按照一定的优先级依次载入某个变异体，在变异后的待测系统上运行待测系统的测试套件并收集结果。最后，当所有变异体都被载入和运行完成之后，变异测试框架会收集整理数据，形成可读的测试报告，从而在一定程度上反映待测系统的测试套件的质量。具体而言，该方法包括以下步骤：
1）变异算子库和算子选择。根据分布式系统集群内通过网络交互、高并发和一致性保障三个特点，基于分布式系统中常见的故障模式和漏洞的文献综述和错误报告分析，设计并实现了网络、并发和一致性三类的变异算子。
每个变异算子基于JavaParser实现，识别待测系统源码中的特定模式并对其按照算子的约束进行修改。此外，采用模块化的设计理念和静态工厂、模板方法等设计模式，使得用户可以根据需要，简单高效地实现自己客制化的变异算子，横向扩展测试框架的能力。
用户在使用本变异测试框架对目标系统进行变异测试时需要定义：（1）变异算子列表，用于生成变异体；（2）待测系统路径；（3）待测系统构造工具，用于支持系统编译和测试套件执行。目前支持maven、ant和gradle；（4）待测系统源码通配符，用于识别需要扫描的源码文件列表，在这些源码文件中才会生成变异体；（5）待测系统构建输出路径，用于在字节码层面识别和删除等效变异体；（6）结果输出路径：用于输出测试结果；（7）是否使用docker（可选），对于不支持并行测试的测试套件，使用docker并行执行以充分利用计算资源，（8）是否开启覆盖率分析（可选），如果开启覆盖率分析，在后续测试套件运行环节，框架仅会执行覆盖变异位置的测试用例，而不会全量执行所有的测试用例。
2）变异体生成。在用户定义了待测系统路径之后，变异测试框架会按照用户指定的源码通配符扫描并构建待测系统的源代码文件列表，并依据用户指定的变异算子列表在这些待测系统源码文件的基础上生成变异体。本变异测试框架每次只对一处代码进行变异，即只生成一阶变异体。
在变异体生成过程中，本框架会通过静态分析方法过滤掉一些无效或等效的变异体。本变异测试框架会通过静态分析手段过滤掉类似的等效或无效的变异体，以降低变异体总数，节省测试套件运行开销，并提高高质量变异体的比例。
除了静态分析的手段之外，本框架还会通过实际编译的方式剔除语法或语义错误的变异体以及消除等效变异体。具体而言，当所有变异体全部生成完成之后，本框架会载入每个变异体，并对载入变异体之后的待测系统进行编译。如果编译失败，则说明变异体存在语法或语义错误，是无效变异体。如果编译成功，框架会收集变异体的变异结果并对所有变异体的编译结果进行两两对比。如果某两个变异体的编译结果完全等价，则说明这两个变异体经过编译优化之后，仍然是等效变异体，对一组等效变异体，本框架只会保留该组中随机一个变异体，以在后续步骤中节省测试运行开销。
3）变异体执行。该步骤会对在步骤2）中生成的所有变异体依次执行待测系统的测试套件，记录测试结果。具体而言，对于每个变异体，测试执行引擎会根据设定的频率和相关性运行测试套件。
4）结果统计和分析。对于每个变异体执行完测试套件之后的输出结果，框架会根据设定关键字的分析结果，根据测试用例的成功或失败来判断该变异体是否存活，并收集运行时间、覆盖测试样例等统计信息。最后汇总所有变异体的测试结果，对测试结果进行评估，计算变异覆盖率、变异杀死率等指标，生成可读的测试报告，识别测试集的不足。
有益效果：与现有技术相比，本发明具有如下优点：
（1）测试覆盖率显著提升：DisMuTe生成的变异体覆盖率达到现有工具的2.2倍。
（2）变异体质量更高：生成的变异体难以被测试用例杀死（“难杀死”），从而有效评估测试集的不足。
（3）工具通用性强：提出的变异操作符适用于多种分布式系统，填补了领域内通用变异操作符设计的空白。
（4）测试效率提升：通过优化的变异体筛选机制，减少无效变异体的生成，降低测试计算开销和测试运行的时间开销。
附图说明
图1是本发明实施例的DisMuTe框架总体架构图；
图2是本发明的实施例的变异体生成与筛选流程图；
图3是操作符应用案例示意图（a）展示了apache-zookeeper-3.5.8版本中Learner.java文件的一个变异体，（b）展示了apache-zookeeper-3.5.8在载入上述变异体之后的单元测试运行情况。
具体实施方式
下面结合具体实施例，进一步阐明本发明，应理解这些实施例仅用于说明本发明而不用于限制本发明的范围，在阅读了本发明之后，本领域技术人员对本发明的各种等价形式的修改均落于本申请所附权利要求所限定的范围。
一种用于分布式系统的变异测试框架，其核心是一套精心设计的具有分布式特征的变异算子，针对分布式系统所固有的复杂性和高并发等特征，能够生成高质量的变异体，并且通过在这些变异体上运行受测系统的测试套件，评估分布式系统测试集的覆盖范围和有效性。变异测试框架包括变异算子库、变异体生成器、测试运行器和结果分析模块，通过实现针对网络、并发和一致性三大领域的算子，覆盖分布式系统中的大量典型故障场景。实验结果表明，本发明相比现有工具（如PIT），能够生成更高质量的变异体，提高测试覆盖率，显著增强测试集的挑战性和有效性。本发明适用于各种分布式系统的质量保障场景，具有良好的通用性和扩展性。
（1）变异算子库设计：针对分布式系统依赖于网络、高并发和需要维护集群内各节点的一致性三个特点出发，设计并实现了网络、并发、一致性三大领域共13个变异算子。变异算子列表如下表所示。
分类	算子缩写	算子英文全称	算子中文全称	算子说明
网络变异算子	MNT	Modify Network Timeouts	修改网络超时时间	修改网络相关特定系统调用或API调用中的超时时间参数
	MNR	Modify Network Resource checks	修改网络资源检查	修改或移除网络相关且涉及前置条件检查的特定系统调用或API调用
	UNE	Upcast Network Exceptions	抛出网络相关异常的超类	当代码逻辑需要抛出网络相关异常时，抛出其超类
	RRC	Remove Resource Closes	移除网络资源关闭	移除网络资源关闭相关的系统调用或API调用
并发变异算子	MCT	Modify Concurrency Timeouts	修改并发超时时间	修改并发操作相关系统调用或API调用中的超时时间参数
	RCS	Remove Critical Sections	移除临界区	移除控制并发线程同步的临界区
	NCS	Narrow down Critical Sections	缩小临界区	收窄控制并发线程同步的临界区
	BCS	Broaden Critical Sections	扩大临界区	扩大控制并发线程同步的临界区
	SCS	Split Critical Sections	分裂临界区	将控制并发线程同步的临界区分裂成两部分
	RTS	Remove concurrency Threads' Synchronizations	移除线程同步	移除线程同步相关的关键字或API调用
	UCE	Upcasting Cocurrency Exceptions	抛出并发相关异常的超类	当代码逻辑需要抛出并发相关异常时，抛出其超类
一致性变异算子	RCF	Remove Consistency File Checks	移除一致性文件检查	移除分布式系统中资源一致性相关文件的前置存在性检查
	UFE	Upcasting consistency File-related Exceptions	抛出一致性文件相关异常的超类	当代码逻辑需要抛出一致性相关异常时，抛出其超类

网络变异算子模拟了分布式系统中常见的网络问题，包括超时、资源泄漏和异常处理不足。如：修改网络超时参数（MNT）、移除网络资源关闭操作（RRC）等。
并发变异算子针对线程同步问题，通过修改代码中的线程同步情况，尝试引发竞争条件或死锁场景。如：修改线程等待时间（MCT）、移除同步锁或同步语句（RTS）等。
一致性变异算子通过删除或修改关键文件操作中的检查和异常处理，以评估测试套件在验证和处理文件相关一致性问题方面的有效性。如：移除文件存在性检查（RCF）、修改或移除文件操作相关的异常处理（RFE）。
（2）变异体生成与筛选：基于变异算子库，通过静态分析和动态执行相结合的方法，筛选出高质量变异体，避免生成冗余或无效变异体（如等效变异体或不可编译的变异体）。确保只有那些可以成功编译和执行的变异体才会被保留用于后续测试阶段。通过仔细过滤掉等效和不可编译的变异体，确保变异测试过程是高效的，这有利于减少运行过程中的时间资源和计算资源的消耗。
（3）框架实现与工具支持：实现了运行引擎，负责根据算子生成变异体、载入变异体、运行测试套件和并评估测试套件的结果。此过程从用变异阶段生成的每个变异体系统地替换原始代码开始。对于每次测试套件的执行，只使用一个变异体，逐个测试它们以避免变异体之间发生冲突或屏蔽。如果系统支持，Docker 等工具可用于此阶段的并行测试，但不在同一环境中运行并行测试，以避免端口冲突导致误报或不稳定的测试。运行完成的结果由结果分析模块统一收集整理，生成统计数据和测试报告。
技术方案的详细描述
测试人员在选定待测系统后，从变异算子库中选择变异测试所需的变异算子；然后，变异测试框架会基于被选择的变异算子，在待测系统的源码基础上生成变异体，并通过静态分析和动态执行相结合的方法筛选掉一些无效变异体或等效变异体；之后进入变异体执行阶段，变异测试框架会根据待测系统单元测试的覆盖率信息，按照一定的优先级依次载入某个变异体，在变异后的待测系统上运行待测系统的测试套件并收集结果。最后，当所有变异体都被载入和运行完成之后，变异测试框架会收集整理数据，形成可读的测试报告，从而在一定程度上反映待测系统的测试套件的质量。具体而言，该方法包括以下步骤。
1）变异算子库和算子选择。我们根据分布式系统集群内通过网络交互、高并发和一致性保障三个特点，设计并实现了网络、并发和一致性三类共13个变异算子。在设计这些算子之前对分布式系统中常见的故障模式和漏洞进行过深入的文献综述和错误报告分析，这确保了算子库全面有效，能够识别和解决分布式系统中的潜在故障。通过关注这些领域，变异算子引入了逼真而强大的变化，模拟了常见的故障场景。
每个变异算子基于JavaParser实现，能够全面高效地识别待测系统源码中的特定模式并对其按照算子的约束进行修改。此外，我们采用模块化的设计理念和静态工厂、模板方法等设计模式，使得用户可以根据需要，简单高效地实现自己客制化的变异算子，横向扩展测试框架的能力。
用户在使用本变异测试框架对目标系统进行变异测试时需要定义：（1）变异算子列表，用于生成变异体；（2）待测系统路径；（3）待测系统构造工具，用于支持系统编译和测试套件执行。目前支持maven、ant和gradle；（4）待测系统源码通配符，用于识别需要扫描的源码文件列表，在这些源码文件中才会生成变异体；（5）待测系统构建输出路径，用于在字节码层面识别和删除等效变异体；（6）结果输出路径：用于输出测试结果；（7）是否使用docker（可选），对于不支持并行测试的测试套件，使用docker并行执行以充分利用计算资源，（8）是否开启覆盖率分析（可选），如果开启覆盖率分析，在后续测试套件运行环节，框架仅会执行覆盖变异位置的测试用例，而不会全量执行所有的测试用例。
2）变异体生成。在用户定义了待测系统源码扫描路径之后，变异测试框架会按照文件通配符扫描所有用户指定的源码文件，并依据用户指定的变异算子列表在这些待测系统源码文件的基础上生成变异体。本变异测试框架每次只对一处代码进行变异，即只生成一阶变异体。
在变异体生成过程中，本框架会通过一定的静态分析方法过滤掉一些无效或等效的变异体。例如，MNT变异算子会将特定调用中的网络超时时间缩短为原来的1/10，但在Zookeeper源码文件QuorumCnxManager.java中的第1188 行 sock.setsoTimeout(0)会被更改为 sock.setsoTimeout(0/10)，经过变异之后的待测系统和原待测系统在语法上是等价的，因此该变异体是一个等效变异体。本变异测试框架会通过一定的静态分析手段过滤掉类似的等效或无效的变异体，以降低变异体总数，节省测试套件运行开销，并提高高质量变异体的比例。
除了静态分析的手段之外，本框架还会通过实际编译的方式剔除语法或语义错误的变异体以及消除等效变异体。具体而言，当所有变异体全部生成完成之后，本框架会载入每个变异体，并对载入变异体之后的待测系统进行编译。如果编译失败，则说明变异体存在语法或语义错误，是无效变异体。如果编译成功，框架会收集变异体的变异结果并对所有变异体的编译结果进行两两对比。如果某两个变异体的编译结果完全等价，则说明这两个变异体经过编译优化之后，仍然是等效变异体，对一组等效变异体，本框架只会保留该组中随机一个变异体，以在后续步骤中节省测试运行开销。
3）变异体执行。该步骤会对在步骤2）中生成的所有变异体依次执行待测系统的测试套件，记录测试结果。具体而言，对于每个变异体，测试执行引擎会根据一定的频率和相关性运行测试套件。例如，如果开启了覆盖率分析功能，对于每个变异体，框架仅会执行覆盖变异位置的测试用例，而不会全量执行所有的测试用例。特别地，我们实施了一种机制来终止大大超出正常执行时间的测试。运行时间大大超过预期的测试将被终止，以防止不必要的时间浪费并确保测试过程保持高效。这种方法有助于在全面测试和实际时间管理之间保持平衡。此外，如果待测系统的测试套件不支持并发测试，本框架提供了docker模式，通过在多个docker容器内同时运行多个变异体，最大化利用计算资源、节省变异测试时间。
4）结果统计和分析。对于每个变异体执行完测试套件之后的输出结果，框架会根据特定关键字的分析结果，根据测试用例的成功或失败来判断该变异体是否存活，并收集运行时间、覆盖测试样例等统计信息。最后汇总所有变异体的测试结果，对测试结果进行评估，计算变异覆盖率、变异杀死率等指标，生成可读的测试报告，识别测试集的不足。

进一步，其中上述步骤1）的具体步骤如下：
步骤1）-1：起始状态；
步骤1）-2：输入变异算子列表；
步骤1）-3：输入待测系统路径；
步骤1）-4：输入待测系统构造工具；
步骤1）-5：输入待测系统源码路径通配符；
步骤1）-6：输入待测系统构建输出路径；
步骤1）-7：输入变异测试结果输出路径；
步骤1）-8：输入是否使用docker；
步骤1）-9：输入是否开启覆盖率分析功能；
步骤1）-10：结束状态；

进一步，其中上述步骤2）的具体步骤如下：
步骤2）-1：起始状态；
步骤2）-2：扫表待测系统源码路径，列出待变异源码文件列表；
步骤2）-3：对列表中每个源码文件依次使用步骤1）中变异算子进行变异；
步骤2）-4：对变异后的文件进行静态分析；
步骤2）-5：将变异后的文件载入待测系统，编译变异体；
步骤2）-6：收集编译结果；
步骤2）-7：比较所有变异体的变异结果；
步骤2）-8：剔除无效变异体和等效变异体；
步骤2）-9：更新变异体列表；
步骤2）-10：结束状态；

进一步，其中上述步骤3）的具体步骤如下：
步骤3）-1：起始状态；
步骤3）-2：若开启了覆盖率分析功能，首先读取用户传入的覆盖率文件，根据单元测试覆盖变异体情况，进行单元测试选择；
步骤3）-3：若开启了docker模式，根据配置启动容器，完成任务分发；
步骤3）-4：载入变异体，运行测试套件；
步骤3）-5：收集测试报告；
步骤3）-6：载入变异体，直到在所有变异体上完成运行测试套件；
步骤3）-7：结束状态；

进一步，其中上述步骤4）的具体步骤如下：
步骤4）-1：起始状态；
步骤4）-2：对每个变异体的测试报告进行关键词分析；
步骤4）-3：收集汇总统计结果，形成变异测试测试报告；
步骤4）-4：结束状态；
以ZooKeeper为例，展示如何通过修改网络超时时间（MNT）生成一个有效变异体，并对测试集的效果进行验证。
其中，图3（a）展示了apache-zookeeper-3.5.8版本中Learner.java文件的一个变异体，这个变异体修改了文件第234行的sock.connect(addr, timeout)这个网络相关API的调用，其中变异体（右）将函数参数的超时时间变为原来的1/10。
附图3（b）展示了apache-zookeeper-3.5.8在载入上述变异体之后的单元测试运行情况，载入变异体后，所有单元测试仍然全部通过，说明使用分布式变异算子库生成的该变异体并没有被杀死，一定程度上印证了本发明分布式变异算子库的有效性。




 

 
图1
 
图2
 
（a）
 
（b）
图3



